import React, { Component, PropTypes } from 'react';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import { fetchEnemies, setBattleScene, setPauseBetweenTurns, setListOfTurnOrder, setNextTurnFromList, setHeroAttackingPos2, getEnemySelectedTarget, setHeroToEnemyTarget, setEnemyAttacking, updateEnemyStats, updateEnemyStatsFromAttack, setHeroAttacking } from '../actions/index';
import classnames from 'classnames';
import { autobind } from 'core-decorators';
import PureComponent from './pure-component';
import * as sounds from '../utils/sound-fx';
import { timer } from '../utils/time-out';
import damageCalcHelper from '../utils/damage-calc';
import getBaseDamage from '../utils/base-damage';
import { fromJS } from 'immutable';

import '../../sass/style.scss';
import '../../sass/_enemies.scss';

@autobind
class Enemy extends PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      test: false,
      isAttacking: false
    };
  }

  componentDidMount() {
    this.props.setListOfTurnOrder('enemy' + this.props.position);
  }

  componentDidUpdate() {
    // console.log(this.props.getListOfTurnOrder.toJS());
    // if (this.props.timer) {
    //   for (let i = 0; i < 4; i++) {
    //     setTimeout(function() {
    //       console.log('waiting...');
    //     }, i * 500)
    //   }
    // }
    // console.log(this.props.getListOfTurnOrder.toJS(), this.props.isEnemyAttacking, this.props.position, this.props.getNextTurn);
    if (this.props.isHeroAttacking ) {
    } else if (this.props.timer) {
      console.log('stop?');
    } else if (!this.props.isEnemyAttacking && this.props.timer && this.props.getNextTurn === 'enemy' + this.props.position) {
      // console.log(this.props.getListOfTurnOrder.toJS());
      // const SET_NEW_LIST = this.props.getListOfTurnOrder.shift();
      // console.log(SET_NEW_LIST.toJS());
      // this.props.setNextTurnFromList(SET_NEW_LIST);
      this.props.setPauseBetweenTurns(false);
      console.log('attacking hero! from: enemy' + this.props.position);
      this.props.setEnemyAttacking(true);
      setTimeout(function () {
        // document.getElementById('enemy' + this.props.position).click();
        this.handleEnemyAttacking();
        this.props.setEnemyAttacking(false);
      }.bind(this), 2000);
    // } else if (this.props.getNextTurn === 'enemy' + this.props.position) {
    //   // console.log('in last if: ' + this.props.getNextTurn);
    //   this.props.setListOfTurnOrder(this.props.getNextTurn);
    //   // console.log('in last if turn order: ' + this.props.getListOfTurnOrder);
    //   this.props.setNextTurnFromList(this.props.getListOfTurnOrder);
    //   this.props.setPauseBetweenTurns();
    //
    // } else if (this.props.getListOfTurnOrder.toJS()[0] === 'enemy' + this.props.position) {
    //   // console.log('last last if: ' + this.props.getListOfTurnOrder);
    //   // this.props.setNextTurnFromList(this.props.getListOfTurnOrder);
    }
  }

  handleEnemyAttacking() {
    if (!this.state.isAttacking) {
      // console.log('attack');
      // const SET_NEW_LIST = this.props.getListOfTurnOrder.toJS().slice(1);
      // console.log(SET_NEW_LIST);
      // console.log(this.props.getListOfTurnOrder.toJS());
      this.props.setNextTurnFromList(this.props.getListOfTurnOrder);
      this.props.setPauseBetweenTurns(true);
      // this.props.setNextTurnFromList(this.props.getListOfTurnOrder);
      // this.props.getEnemySelectedTarget('hero1', getBaseDamage(this.props.str, this.props.level));
      // this.props.setListOfTurnOrder(this.props.getListOfTurnOrder.toJS()[1]);
      this.setState({
        isAttacking: true
      });
      setTimeout(function () {
        this.setState({
          isAttacking: false
        });
      }.bind(this), 850);
    }
  }

  handleHeroAttacking(enemyTarget) {
    // console.log('getNextTurn: ' + this.props.getNextTurn);
    const enemyStats = this.props['enemyStats' + this.props.position];
    const newHp = enemyStats.currentHp - this.getDamageAmount(enemyStats);
    const newStats = this.props.enemyStats.find(function (stat) {
      return stat.get('id') === this.props.position;
    }.bind(this)).set('currentHp', newHp);

    this.props.setHeroAttacking(false);
    this.props.updateEnemyStats(newStats.toJSON(), this.props.position);
    this.props.setListOfTurnOrder(this.props.getNextTurn);
    this.props.setPauseBetweenTurns(true);

    console.log('%cdamage: ' + this.getDamageAmount(enemyStats), 'color: orange');
    console.log('%cEnemy Health: ' + newHp, 'color: green');
    this.props.setNextTurnFromList(this.props.getListOfTurnOrder);
  }

  getDamageAmount(enemy) {
    // console.log(enemy.def, this.props.heroStr);
    const power = 4;
    let damage = damageCalcHelper(power, enemy.def, this.props.heroStr);
    damage = damage > 0 ? damage : 1;
    return damage;
  }

  handleTest() {
    console.log(this.props.isHeroAttacking, this.props.getListOfTurnOrder.toJS());
    if (this.props.isHeroAttacking) {
      // console.log(this.props.getListOfTurnOrder.toJS());
      const enemyTarget = this.props['isEnemyTarget' + this.props.position];
      this.handleHeroAttacking(enemyTarget);
      this.props.setHeroToEnemyTarget(true, this.props.position);
      // this.props.setHeroAttacking(false);
      // this.handleHeroAttacking();
      // timer(550, this.props.setHeroAttackingPos2, true);
      // timer(1300, this.props.setHeroAttackingPos2, false);
      console.log('finished');
      timer(1300, this.props.setHeroToEnemyTarget, false, this.props.position);
    // } else if (this.props.position.toString() === this.props.getNextTurn.slice(5)) {
    //   // setTimeout(function () {
    //   // console.log(this.props.getListOfTurnOrder.toJS());
    //   if (!this.state.isAttacking) {
    //     // console.log('attack');
    //     // const SET_NEW_LIST = this.props.getListOfTurnOrder.toJS().slice(1);
    //     // console.log(SET_NEW_LIST);
    //     // this.props.setNextTurnFromList(fromJS(SET_NEW_LIST));
    //     this.props.setNextTurnFromList(this.props.getListOfTurnOrder);
    //     this.props.setPauseBetweenTurns(true);
    //     // this.props.setNextTurnFromList(this.props.getListOfTurnOrder);
    //     // this.props.getEnemySelectedTarget('hero1', getBaseDamage(this.props.str, this.props.level));
    //     // this.props.setListOfTurnOrder(this.props.getListOfTurnOrder.toJS()[1]);
    //     this.setState({
    //       isAttacking: true
    //     });
    //     setTimeout(function () {
    //       this.setState({
    //         isAttacking: false
    //       });
    //     }.bind(this), 850);
      // }
      // }.bind(this), 1000);
    }
  }

  setMusic() {
    return (
      <audio
        controls name="media"
        src="/resources/music/swipe.mp3"
        autoPlay
        type="audio/mpeg"
      />
    );
  }

  render() {
    // console.log(this.props);
    const enemyClass = {
      'enemy-sprites': true,
      'enemy-attack-hero1': this.state.isAttacking
    };
    return (
      <div>
        <div
          id={"enemy" + this.props.position}
          onClick={this.handleTest}
          className={classnames(enemyClass) + " " + this.props.enemyClass + " enemy" + this.props.position}
        />
        {this.state.isAttacking ? sounds.enemyAttackFX() : null}
      </div>
    );
  }
}

Enemy.propTypes = {
  str: PropTypes.number,
  heroStr: PropTypes.number,
  level: PropTypes.number,
  getEnemySelectedTarget: PropTypes.func,
  setEnemyAttacking: PropTypes.func,
  enemyClass: PropTypes.string,
  position: PropTypes.number,
  setHeroAttacking: PropTypes.func,
  updateEnemyStats: PropTypes.func,
  isHeroAttacking: PropTypes.bool,
  currentHp: PropTypes.number,
  enemyStats: PropTypes.array,
  def: PropTypes.number,
  updateEnemyStats: PropTypes.func,
  setHeroToEnemyTarget: PropTypes.func
};

function mapStateToProps(state) {
  // console.log(state.get('enemyStats'));
  return {
    isEnemyAttacking: state.get('isEnemyAttacking').toJS()[0],
    // isHeroAttacking: state.get('getNextTurn').toJS()[0] === 'hero1' ? true : false,
    isHeroAttacking: state.get('isHeroAttacking').isHeroAttacking,
    heroStr: state.get('updateCharacterStats').get('str'),
    enemyStats: state.get('enemyStats').toArray(),
    enemyStats0: state.get('enemyStats').toJS()[0] ? state.get('enemyStats').toJS()[0] : null,
    enemyStats1: state.get('enemyStats').toJS()[1] ? state.get('enemyStats').toJS()[1] : null,
    enemyStats2: state.get('enemyStats').toJS()[2] ? state.get('enemyStats').toJS()[2] : null,
    enemyStats3: state.get('enemyStats').toJS()[3] ? state.get('enemyStats').toJS()[3] : null,
    enemyStats4: state.get('enemyStats').toJS()[4] ? state.get('enemyStats').toJS()[4] : null,
    isEnemyTarget0: state.get('isEnemyTarget').toJS()[0],
    isEnemyTarget1: state.get('isEnemyTarget').toJS()[1],
    isEnemyTarget2: state.get('isEnemyTarget').toJS()[2],
    isEnemyTarget3: state.get('isEnemyTarget').toJS()[3],
    isEnemyTarget4: state.get('isEnemyTarget').toJS()[4],
    isEnemyTarget: state.get('isEnemyTarget'),
    getNextTurn: state.get('getNextTurn').toJS()[0],
    getListOfTurnOrder: state.get('getListOfTurnOrder'),
    timer: state.get('timer').toJS()[0]
  };
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators({ fetchEnemies, setBattleScene, setPauseBetweenTurns, setListOfTurnOrder, setNextTurnFromList, setHeroAttackingPos2, getEnemySelectedTarget, setHeroToEnemyTarget, setEnemyAttacking, updateEnemyStats, updateEnemyStatsFromAttack, setHeroAttacking }, dispatch);
}

export default connect(mapStateToProps, mapDispatchToProps)(Enemy);
